package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"image/png"
	"io"
	"log"
	"net/http"
	"os"
	"runtime"
	"strings"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/canvas"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/widget"
)

//go:embed logo.png
var logo []byte

//go:embed bl.sources
var blSources string

//go:embed wl.sources
var wlSources string

func contains(slice []string, val string) bool {
	for _, v := range slice {
		if strings.Contains(val, v) {
			return true
		}
	}
	return false
}

func fetchblacklist(wl []string, bla []string) string {

	blist := strings.Split(blSources, "\n")
	blackl := ""
	for _, cururl := range blist {

		resp, err := http.Get(cururl)
		if err != nil {
			fmt.Println("Error occured while fetching adress: ", err)
			continue
		}

		data, err := io.ReadAll(resp.Body)
		if err != nil {
			fmt.Println("Error occured while reading fetched data: ", err)
			continue
		}
		blackl += string(data)
		resp.Body.Close()
	}
	wlist := strings.Split(wlSources, "\n")

	whitel := ""
	for _, cururl := range wlist {

		resp, err := http.Get(cururl)
		if err != nil {
			fmt.Println("Error occured while fetching adress: ", err)
			continue
		}

		data, err := io.ReadAll(resp.Body)
		if err != nil {
			fmt.Println("Error occured while reading fetched data: ", err)
			continue
		}
		whitel += string(data)
		resp.Body.Close()
	}
	awl := append(strings.Split(whitel, "\n"), wl...)
	lines := append(strings.Split(blackl, "\n"), bla...)
	fixedLines := []string{}
	for _, line := range lines {
		line = strings.TrimSpace(line)

		if line == "" || strings.HasPrefix(line, "#") {

			continue
		}

		parts := strings.Fields(line)
		var domain string

		if len(parts) == 1 {
			domain = parts[0]
		} else if len(parts) >= 2 {
			domain = parts[1]
		}

		isWhitelisted := false
		for _, w := range awl {
			if domain == strings.TrimSpace(w) {
				isWhitelisted = true
				break
			}
		}

		if !isWhitelisted && domain != "" {
			fixedLines = append(fixedLines, "0.0.0.0 "+domain)
		}
	}
	return "# this list was generated by SAdBlocker \n # by maksydab \n" + strings.Join(fixedLines, "\n")
}
func wop(wla string, bla string) {
	bl := fetchblacklist(strings.Split(wla, "\n"), strings.Split(bla, "\n"))

	var hostsPath string
	switch runtime.GOOS {
	case "windows":
		hostsPath = `C:\Windows\System32\drivers\etc\hosts`
	case "darwin":
		hostsPath = `/etc/hosts`
	case "linux":
		hostsPath = `/etc/hosts`
	default:
		fmt.Println("Unsupported OS")
		return
	}

	err := os.WriteFile(hostsPath, []byte(bl), 0644)
	if err != nil {
		fmt.Println("Error writing hosts file:", err)
	} else {
		fmt.Println("Hosts file updated:", hostsPath)
	}
}
func main() {
	a := app.NewWithID("com.github.maksydab.sadblocker")
	w := a.NewWindow("SAd Blocker")

	message := widget.NewLabel("Welcome to SAd blocker")
	winput := widget.NewEntry()
	winput.SetPlaceHolder("Enter whitelist domains...")
	winput.MultiLine = true
	winput.SetMinRowsVisible(6)
	binput := widget.NewEntry()
	binput.SetPlaceHolder("Enter blacklist domains...")
	binput.MultiLine = true
	binput.SetMinRowsVisible(6)

	updateButton := widget.NewButton("Update", func() {
		go wop(winput.Text, binput.Text)
	})

	docsButton := widget.NewButton("Docs", func() {
		docsWin := a.NewWindow("Documentation")
		docsContent := `Welcome to SAdBlocker!

Instructions:
- Enter whitelist domains in the top box.
- Enter blacklist domains in the bottom box.
- Click Update to apply changes to the hosts file.
- Make sure you run the program with sufficient permissions.
The format for both whitelist and blacklist is as follows:
- each new line is a single entry 
- each entry will be matched in every possible 
  way so if u enter into whitelist ".com" it will 
  allow every domain with .com and if u enter "wiki" 
  then it will allow any domain with wiki in name
- for blacklist if u have "site.com" it will block all trafic from "site.com"
  like "site.com/example" but not from "sub.site.com"
`

		label := widget.NewLabel(docsContent)
		label.Wrapping = fyne.TextWrapWord
		scroll := container.NewVScroll(label)
		docsWin.SetContent(scroll)
		docsWin.Resize(fyne.NewSize(400, 300))
		docsWin.Show()
	})
	reader := bytes.NewReader(logo)

	img, err := png.Decode(reader)
	if err != nil {
		log.Fatal(err)
	}

	imageCanvas := canvas.NewImageFromImage(img)
	imageCanvas.FillMode = canvas.ImageFillContain
	warlabel := widget.NewLabel("⚠️WARNING: don't press update button too quick as its resource intensive")
	w.SetContent(container.NewVBox(message, imageCanvas, winput, binput, docsButton, warlabel, updateButton))
	w.Resize(fyne.NewSize(512, 320))
	w.ShowAndRun()
}
